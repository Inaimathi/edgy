# EAF
#### Parsing scanned bitmaps for flow diagrams and visual programming

# Basics

So here's approximately what we want

#### Example Input

    ..............................
    ....xx........................
    ...xxxxxxxxxxxxxxxxxxxx.......
    .xxxxxxxxxxxxxxxxxxxxxxx......
    ..xxxxxx....xxxx...xxxxxx.....
    ...xxxxx...........xxxxx......
    ...xxxx.............xxxx......
    ....xxx.............xxx.......
    ...xxxx............xxxx.......
    ...xxx.............xxxx.......
    ..xxxxx............xxxxx......
    ..xxxxx............xxxxx......
    ..xxxxxx.........xxxxxxx......
    ...xxxxxxxxxxxxxxxxxxxx.......
    ...xxxxxxxxxxxxxxxxxx.........
    ..........xxxxxx..............
    ...........xxxxx..............
    ...........xxxx...............
    ...........xxxx...............
    ..........xxxxx...............
    ..........xxxx................
    ....xxx....xxxxx....xxx.......
    ....xxxx..xxxxx....xxxxx......
    .....xxx...xxxx...xxxxxx......
    ......xxx.xxxxx..xxxxxx.......
    .......xxxxxxxx.xxxxx.........
    ........xxxxxxxxxxx...........
    ..........xxxxxxxx............
    ...........xxxxx..............
    ............xx................
    .........xxxxxxxxx............
    .....xxxxxxxxxxxxxxxx.........
    ....xxxxxxx....xxxxxxx........
    ...xxxxx..........xxxx........
    ...xxxx............xxxx.......
    ..xxxx.............xxxxx......
    ..xxxx..............xxxxx.....
    ..xxxx..............xxxxx.....
    ..xxxx..............xxxx......
    ...xxxx...........xxxxx.......
    ...xxxxxxx.....xxxxxxxx.......
    ....xxxxxxxxxxxxxxxxx.........
    .......xxxxxxxxxxx............
    ..........xxxx................
    ..............................
    ..............................
    ..............................

#### Acceptable outputs

Actual shape recognition _(I'm assuming hard)_

	Square (3, 4) (14, 21)
	Arrow (14, 13) (30, 13)
	Circle (37,12) 10

Line recognition _(maybe easier? but we can use it to generate the above within a certain tolerance)_

	Line (3, 4) (3, 20)
	Line (3, 4) (14, 4)
	Line (14, 4) (14, 21)
	Line (3, 20) (14, 21)
	Line (14, 13) (30, 13)
	Line (22, 3) (30, 13)
	Line (30, 13) (22, 22)
	Line (31, 12) (35, 4)
	Line (35, 4) (41, 4)
	Line (41, 4) (44, 11)
	Line (44, 11) (40, 22)
	Line (40, 20) (33, 21)
	Line (33, 21) (30, 13)

The circle might be composed of curves rather than straight lines. The output data format doesn't particularly matter; I'm only incidentally using the standard Haskell `show` format above because this happens to be a Haskell project.

### Direction mapping

This is the principle approach I've settled on for generating line vectors from bitmap line drawings. The relevant files are in [`Direction.hs`](https://github.com/Inaimathi/EAF/blob/master/Direction.hs). The main function defined is `getDirections`, which takes a sparse image and returns its cardinal and ordinal direction maps.

       ||                          +    \/                         
      --------------------         +   \o\////\\\\///\\\\o/        
    -----------------------        + \\o\o///oo\\oo//o\\\oo/       
     --|||-    ----   -|||--       +  \\o///    oooo   \\\o//      
      o|||-           -|||-        +   \o///           o\\o/       
      ||||             |||o        +   /\//             o\/o       
       |||             |||         +    /oo             //\        
      ||||            ||||         +   \//\            o///        
      |||             ||||         +   o\/             /o//        
     -|||o            ||||-        +  /o\\/            /////       
     -|||o            ||||-        +  /o\\\            ///oo       
     -|||--         --o|||-        +  /\\\\\         /////o\       
      --------------------         +   /o\\\\\\\\o////////\        
      ---------||-------           +   /o\\\\\\\\o///////          
             -||||-                +          \\\///               
              ||||-                +           \\///               
              ||||                 +           /\/o                
              ||||                 +           //\\                
             -||||                 +          ////\                
             -|||                  +          /o/o                 
       -o|    ||||-    |||         +    \\o    o\///    ///        
       --oo  -||||    -o---        +    \\\o  \\///    /////       
        o||   ||||   ------        +     \\\   oo/o   /////\       
         ||o -||||  ------         +      \\\ //o\\  /////\        
          ----|||o ----o           +       \\\//o\\ /////          
           ---|||-----             +        /\\/\\\////            
             -|||o---              +          \\o\////             
              ||||-                +           \\///               
               ||                  +            o\                 
            ---||----              +         ////\\\\\             
        -------||-------           +     o//////oo\\\\\\/          
       ||----     -----||          +    o/////     \\\\\\/         
      |||--          -|||          +   o////          \\\\         
      |||o            ||||         +   ////            \\\\        
     o|||             o|||-        +  \///             \\\\/       
     o|||              |||--       +  \\/o              \\o\o      
     o|||              |||--       +  //\o              o/\\\      
     o|||              |||o        +  /\\\              ///\       
      |||-           --|||         +   \\\\           /////        
      |||----     -----||-         +   /\\\\\\     ///////\        
       -----------------           +    /\\\\\\\/////////          
          -----------              +       \\\\\o/////             
             ----                  +          \\o/                 
                                   +                               
                                   +                               
                                   +                               
                                   +                               

Using this information, we can separate contiguous regions into islands, and assemble the dominating ones (by size) into a series of lines that represent the same image. That's done in the [`Elements.hs` file](https://github.com/Inaimathi/EAF/blob/master/Elements.hs), and the result of this operation is a series of `Element`s (just `Line`s at the moment, but `Ellipse` and/or `Curve`, and probably `Text` are coming in the future). Once we've generated elements, we align their points within a certain tolerance; things that _almost_ line up are made to line up precisel, on the assumption that our input is coming from humans.

The current output of this process can be seen in the [`test-data/` folder](https://github.com/Inaimathi/EAF/tree/master/test-data). Each `.txt` file is an input, and the corresponding output is in the similarly named `.svg` file. The output for the above example input can be found [here](https://github.com/Inaimathi/EAF/blob/master/test-data/single-color.svg).

The next thing we need to do is deal with overlapping elements somehow. In particular, if a previous processing step outputs something like

    A          C    B          D
    +----------+----+----------+

where line segments `A->B` and `C->D` have the same slope and overlap partially, we'd really like to replace them with the line segment `A->D` instead. The equivalent applies to lines going in all directions.

### General Notes

- The current examples and experimentation are based on `ascii` representations of our target images. I'm assuming that once I figure out the principles, porting them over to a pixel context won't prove too difficult (in fact, having the additional hue/saturation/RGB data around might help analysis once we get to that stage).
- The current examples all have a much higher `line-width` : `image-size` ratio than actuall inputs will have. This _complicates_ generation slightly, and makes it pretty hard to disambiguate circles from polygons. I expect that to become easier as we lower the ratio.
- These are not experiments for generic object identification. The idea here is to take dead bitmaps and generate flow diagrams for [visual programs](http://langnostic.inaimathi.ca/article?name=the-big-problem-and-visual-compilers.html) from them. This means we're dealing with a very restricted set of images:
	- All white background
	- Some sparse text
	- Only line drawings
- The idea is to get something practically workable, and not necessarily start out with the general case solution. In particular, I'm perfectly willing to "cheat" by adding the restriction that lines/arrows and shapes be represented in different colors. So as far as I'm concerned, another perfectly legitimate example is something like [this](https://github.com/Inaimathi/EAF/blob/master/test-data/multi-color.txt). At the current level of experimentation, it doesn't seem to make as big a difference as I thought it might (as you can see by comparing [this](https://github.com/Inaimathi/EAF/blob/master/test-data/single-color.txt)->[this](https://github.com/Inaimathi/EAF/blob/master/test-data/single-color.svg) to [this](https://github.com/Inaimathi/EAF/blob/master/test-data/multi-color.txt)->[this](https://github.com/Inaimathi/EAF/blob/master/test-data/multi-color.svg).) There's really no reason _not_ to support it, since the exact same machinery can handle single and multi-color inputs, but I don't think I'll be putting emphasis on color coded images for the moment.
