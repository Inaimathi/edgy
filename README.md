# EAF
#### Parsing scanned bitmaps for flow diagrams and visual programming

# Basics

So here's approximately what we want

#### Example Input

    ..............................
    ....xx........................
    ...xxxxxxxxxxxxxxxxxxxx.......
    .xxxxxxxxxxxxxxxxxxxxxxx......
    ..xxxxxx....xxxx...xxxxxx.....
    ...xxxxx...........xxxxx......
    ...xxxx.............xxxx......
    ....xxx.............xxx.......
    ...xxxx............xxxx.......
    ...xxx.............xxxx.......
    ..xxxxx............xxxxx......
    ..xxxxx............xxxxx......
    ..xxxxxx.........xxxxxxx......
    ...xxxxxxxxxxxxxxxxxxxx.......
    ...xxxxxxxxxxxxxxxxxx.........
    ..........xxxxxx..............
    ...........xxxxx..............
    ...........xxxx...............
    ...........xxxx...............
    ..........xxxxx...............
    ..........xxxx................
    ....xxx....xxxxx....xxx.......
    ....xxxx..xxxxx....xxxxx......
    .....xxx...xxxx...xxxxxx......
    ......xxx.xxxxx..xxxxxx.......
    .......xxxxxxxx.xxxxx.........
    ........xxxxxxxxxxx...........
    ..........xxxxxxxx............
    ...........xxxxx..............
    ............xx................
    .........xxxxxxxxx............
    .....xxxxxxxxxxxxxxxx.........
    ....xxxxxxx....xxxxxxx........
    ...xxxxx..........xxxx........
    ...xxxx............xxxx.......
    ..xxxx.............xxxxx......
    ..xxxx..............xxxxx.....
    ..xxxx..............xxxxx.....
    ..xxxx..............xxxx......
    ...xxxx...........xxxxx.......
    ...xxxxxxx.....xxxxxxxx.......
    ....xxxxxxxxxxxxxxxxx.........
    .......xxxxxxxxxxx............
    ..........xxxx................
    ..............................
    ..............................
    ..............................

#### Acceptable outputs

Actual shape recognition (I'm assuming hard)

	Square (3, 4) (14, 21)
	Arrow (14, 13) (30, 13)
	Circle (37,12) 10

Line recognition (maybe easier? but we can use it to generate the above within a certain tolerance)

	Line (3, 4) (3, 20)
	Line (3, 4) (14, 4)
	Line (14, 4) (14, 21)
	Line (3, 20) (14, 21)
	Line (14, 13) (30, 13)
	Line (22, 3) (30, 13)
	Line (30, 13) (22, 22)
	Line (31, 12) (35, 4)
	Line (35, 4) (41, 4)
	Line (41, 4) (44, 11)
	Line (44, 11) (40, 22)
	Line (40, 20) (33, 21)
	Line (33, 21) (30, 13)

The circle might be composed of curves rather than straight lines. The output data format doesn't particularly matter; I'm only incidentally using the standard Haskell `show` format above.

The above is obviously not happening yet. This repo is still a work heavily in progress. Here you can find the test data and some experiments with edge thinning and line directions.

### Thinning 
`Ping.hs` contains some thoughts and experiments relating to the centrality of a particular pixel. As of this writing its output, given the above input, is

    ...xx......................... + ...xx.........................
    ..xxxxxxxxxxxxxxxxxxxx........ + .......xxxx....xxx............
    xxxxxxxxxxxxxxxxxxxxxxx....... + xx.....xxxxxxxxxxx............
    .xxxxxx....xxxx...xxxxxx...... + .xx....................x......
    ..xxxxx...........xxxxx....... + ....xx..............x.........
    ..xxxx.............xxxx....... + ..............................
    ...xxx.............xxx........ + ....x...............x.........
    ..xxxx............xxxx........ + ..x..x.............x..........
    ..xxx.............xxxx........ + ...x..........................
    .xxxxx............xxxxx....... + ...x................x.........
    .xxxxx............xxxxx....... + .xxx..............x.x.x.......
    .xxxxxx.........xxxxxxx....... + .....x.............x..........
    ..xxxxxxxxxxxxxxxxxxxx........ + ......xxx......xxx............
    ..xxxxxxxxxxxxxxxxxx.......... + .......xxx.....x..............
    .........xxxxxx............... + ..............................
    ..........xxxxx............... + ............xx................
    ..........xxxx................ + ..............................
    ..........xxxx................ + ..............................
    .........xxxxx................ + .........x.x..................
    .........xxxx................. + ..............................
    ...xxx....xxxxx....xxx........ + ...xx.......x.x.....x.........
    ...xxxx..xxxxx....xxxxx....... + ...xx....x.xx.......x.x.......
    ....xxx...xxxx...xxxxxx....... + .....x.............x..x.......
    .....xxx.xxxxx..xxxxxx........ + ......x..x.x..................
    ......xxxxxxxx.xxxxx.......... + .......xx........x............
    .......xxxxxxxxxxx............ + ........x...x..x..............
    .........xxxxxxxx............. + ..............x...............
    ..........xxxxx............... + ............x.................
    ...........xx................. + ...........xx.................
    ........xxxxxxxxx............. + .........x..x.................
    ....xxxxxxxxxxxxxxxx.......... + .......xxxx..xxxx.............
    ...xxxxxx.....xxxxxxx......... + ......xx.........x............
    ..xxxxx..........xxxx......... + ....x.............x...........
    ..xxxx............xxxx........ + ..............................
    .xxxx.............xxxxx....... + ....................x.........
    .xxxx..............xxxxx...... + ....x..............xxx.x......
    .xxxx..............xxxxx...... + .....................x.x......
    .xxxx..............xxxx....... + ..............................
    ..xxxx...........xxxxx........ + ...................x..........
    ..xxxxxxx.....xxxxxxxx........ + .....x...........xx...........
    ...xxxxxxxxxxxxxxxxx.......... + ......xxx..x.xxxx.............
    ......xxxxxxxxxxx............. + .........xxxxx................
    .........xxxx................. + ..............................
    .............................. + ..............................
    .............................. + ..............................
    .............................. + ..............................
    .............................. + ..............................

### Direction mapping

`Direction.hs` contains some thoughts and experiments based on mapping the cardinal and ordinal directions of particular pixels, based on their contiguous neighborhood. The initial model it produces looks something like

       ||                          +    \/                         
      --------------------         +   \O\////\\\\///\\\\O/        
    -----------------------        + \\O\O///OO\\OO//O\\\OO/       
     --|||-    ----   -|||--       +  \\O///    OOOO   \\\O//      
      O|||-           -|||-        +   \O///           O\\O/       
      ||||             |||O        +   /\//             O\/O       
       |||             |||         +    /OO             //\        
      ||||            ||||         +   \//\            O///        
      |||             ||||         +   O\/             /O//        
     -|||O            ||||-        +  /O\\/            /////       
     -|||O            ||||-        +  /O\\\            ///OO       
     -|||--         --O|||-        +  /\\\\\         /////O\       
      --------------------         +   /O\\\\\\\\O////////\        
      ---------||-------           +   /O\\\\\\\\O///////          
             -||||-                +          \\\///               
              ||||-                +           \\///               
              ||||                 +           /\/O                
              ||||                 +           //\\                
             -||||                 +          ////\                
             -|||                  +          /O/O                 
       -O|    ||||-    |||         +    \\O    O\///    ///        
       --OO  -||||    -O---        +    \\\O  \\///    /////       
        O||   ||||   ------        +     \\\   OO/O   /////\       
         ||O -||||  ------         +      \\\ //O\\  /////\        
          ----|||O ----O           +       \\\//O\\ /////          
           ---|||-----             +        /\\/\\\////            
             -|||O---              +          \\O\////             
              ||||-                +           \\///               
               ||                  +            O\                 
            ---||----              +         ////\\\\\             
        -------||-------           +     O//////OO\\\\\\/          
       ||----     -----||          +    O/////     \\\\\\/         
      |||--          -|||          +   O////          \\\\         
      |||O            ||||         +   ////            \\\\        
     O|||             O|||-        +  \///             \\\\/       
     O|||              |||--       +  \\/O              \\O\O      
     O|||              |||--       +  //\O              O/\\\      
     O|||              |||O        +  /\\\              ///\       
      |||-           --|||         +   \\\\           /////        
      |||----     -----||-         +   /\\\\\\     ///////\        
       -----------------           +    /\\\\\\\/////////          
          -----------              +       \\\\\O/////             
             ----                  +          \\O/                 
                                   +                               
                                   +                               
                                   +                               
                                   +                               

which represents the cardinal and ordinal direction map of the image. Using this information, and some island size/dimension comparisons, we might be able to pull out the intended lines from the given image.

The current code generates region data from the above (the output is too large to paste here; run `main` from `Direction.hs` if you'd like to see it). The problem I'm running into is that arrowhead strokes connected to circles are blending together, so I'm getting much larger regions than I was expecting, and they represent multiple strokes in the image. This is something that would be solved pretty handily by the multi-color cheat I've been talking about, so I might just go ahead and implement that next.

### General Notes

- The current examples and experimentation are based on ascii representations of our target images. I'm assuming that once I figure out the principles, porting them over to a pixel context won't prove too difficult (in fact, having the additional hue/saturation/RGB data around might help analysis once we get to that stage).
- These are not experiments for generic scene carving/object identification. The idea here is to take dead bitmaps and generate flow diagrams for [visual programs](http://langnostic.inaimathi.ca/article?name=the-big-problem-and-visual-compilers.html) from them. This means we're dealing with a very restricted set of images:
	- All white background
	- Some sparse text
	- Only line drawings
- The idea is to get something practically workable, and not necessarily start out with the general case solution. In particular, I'm perfectly willing to "cheat" by adding the restriction that lines/arrows and shapes be represented in different colors. So as far as I'm concerned, another perfectly legitimate example input is the following:

_two-color_

    ..............................
    ....xx........................
    ...xxxxxxxxxxxxxxxxxxxx.......
    .xxxxxxxxxxxxxxxxxxxxxxx......
    ..xxxxxx....xxxx...xxxxxx.....
    ...xxxxx...........xxxxx......
    ...xxxx.............xxxx......
    ....xxx.............xxx.......
    ..xxxx............xxxx.......
    ...xxx.............xxxx.......
    ..xxxxx............xxxxx......
    ..xxxxx............xxxxx......
    ..xxxxxx.........xxxxxxx......
    ...xxxxxxxxxxxxxxxxxxxx.......
    ...xxxxxxxxooooxxxxxx.........
    ..........oooooo..............
    ...........ooooo..............
    ...........oooo...............
    ...........oooo...............
    ..........ooooo...............
    ..........oooo................
    ....ooo....ooooo....ooo.......
    ....oooo..ooooo....ooooo......
    .....ooo...oooo...oooooo......
    ......ooo.ooooo..oooooo.......
    .......oooooooo.ooooo.........
    ........ooooooooooo...........
    ..........oooooooo............
    ...........ooooo..............
    ............oo................
    .........xxxxxxxxx............
    .....xxxxxxxxxxxxxxxx.........
    ....xxxxxxx....xxxxxxx........
    ...xxxxx..........xxxx........
    ...xxxx............xxxx.......
    ..xxxx.............xxxxx......
    ..xxxx..............xxxxx.....
    ..xxxx..............xxxxx.....
    ..xxxx..............xxxx......
    ...xxxx...........xxxxx.......
    ...xxxxxxx.....xxxxxxxx.......
    ....xxxxxxxxxxxxxxxxx.........
    .......xxxxxxxxxxx............
    ..........xxxx................
    ..............................
    ..............................
    ..............................

